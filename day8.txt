前情回顾

信号 ：在进程间通过信号传递讯息
信号处理函数： 
  os.kill(pid,sig) 发送信号
    signal.alarm(sec)  向自己发送时钟
    signal.pause()  阻塞等待
    signal.signal(sig,handler) 处理信号
     handler（sig,frame）

信号量  Semaphore()
  acquire()   删除信号量
    release()   添加信号量
    get_value() 获取信号量值

同步互斥机制 ： 解决对共享资源的争夺
event  事件
e.wait()  e.set()  e.clear()

lock 锁
acquire() 上锁
release() 解锁

threading 创建线程
Thread() 线程创建类
t.start()
t.join()
***************************************************
线程间通信 

通信方法 : 多个线程共用进程空间，所以进程的全局量对进程内的线程均可见。因此线程间没有特有的通信方式往往使用全局变量通信

注意事项 ：线程间使用全局变量通信往往需要同步互斥机制做为通信的安全保证

线程的同步互斥

线程event对象

创建对象 ： 
  e = threading.Event()
  e.wait([timeout])  如果e为设置状态则不会阻塞，未设置则阻塞
  e.set()            将e变为设置状态
  e.clear()          将e的设置去除

线程锁
lock = threading.Lock() 创建锁对象
lock.acquire()  上锁
lock.release()  解锁

* 在一个进程中对一个线程锁重复上锁则会阻塞

Python线程的GIL问题 （全局解释器锁）

python ---> 支持多线程 --> 同步互斥 --> 加锁 ---> 超级锁，给解释器加锁

后果 ： 一个解释器，同一时刻只能解释一个线程。因此大大降低了Python线程的执行效率

Python 的GIL问题 解决方法
* 尽量使用进程方式并行
* 不适用c作为解释器  c# java
* Python线程适用于高延迟的IO操作，网络操作。不适合用cpu密集型程序。线程在遇到IO阻塞时会让出解释器和cpu

效率测试 

分别测试 在IO密集型程序和CPU密集型程序下，多进程，多线程，单进程执行效率

Line cpu: 8.061699390411377
Line io: 5.261598348617554

Thread cpu: 8.920610427856445
Thread io: 5.60230565071106

process cpu: 4.07219386100769
Process io: 3.383375406265259

进程和线程的区别和联系
1.两者都是多任务编程的方式，都能够使用计算机多核
2.进程的创建和删除要比线程消耗更多计算机资源
3.进程空间独立，数据安全性好，有专门的进程间通信方法
4.线程使用全局变量通信，更加简单，但是往往要与同步互斥机制公用
5.一个进程可以包含多个线程，线程共享进程的资源空间
6.进线程都有自己特有的资源，如命令，属性 id等

使用场景 : 
* 需要创建较多的并发，任务比较简单时，线程比较合适
* 如果程序数据资源比较复杂，特别是共享资源较多时，需要考虑到线程锁的复杂性
* 如果多个任务无必要的关联性，不易将其强行融入到一个进程中
* Python线程不适合cpu密集型程序

总结 ： 
1. 进程线程的区别和关系
2. 进程间以什么方式通信，有什么特点
3. 同步互斥的意义，有什么方法实现同步互斥
4. 僵尸进程，进程状态，线程GIL的概念
5. 给一个情景，问选择进程还是线程，怎么做为什么


服务器模型

硬件服务器: 主机  集群
厂商:      IBM   HP   联想   浪潮

软件服务器: 编写的服务端程序，依托于硬件服务器运行，提供给用户一定的软件服务

分类: 
      webserver  -----> 网络后端程序提供网络请求的后端处理和数据交互 
      httpserver -----> 处理HTTP请求，回复http响应
      邮箱服务器   -----> 提供邮箱服务
      文件服务器   -----> 提供文件的上传下载

功能: 网络连接，逻辑处理，数据的交互，数据的传输
       协议的实现

模型结构:
        c/s  (客户端服务器模型)
        b/s  (浏览器服务器模型)

服务器目标: 处理速度快，数据更安全，并发量大 

硬件: 更高的配置，集成分布的技术，更好的网络速度，更多的主机，网络安全

软件: 程序占有更少的计算机资源，更稳定的运行效果，更流畅的运行速度，采用更合理的技术。处理更高的并发

服务器模型

循环服务器：单进程程序，循环的接收客户端的请求，处理请求，每处理完一个请求后再去接收处理下一个请求 

优点:实现简单，占用系统资源少
缺点:无法同时连接多个客户端，当一个客户端长期占有服务器时会形成其他客户端无法访问的情况使用情况: 任务比较短暂，udp套接字更适合循环


并发服务器: 同时能够处理多个客户端的任务请求。并发可分为IO并发或者多进程多线程并发。
    
IO并发:IO多路复用协程

优点：资源消耗少，适用于IO类型服务器
缺点：不能监控CPU密集的情况，单线程，不能长期阻塞消息的收发

进程/线程并发: 为每个客户端单独提供一个进程线程，处理客户端请求

优点:客户端可以长期占用服务器
缺点:消耗系统资源较多

多进程并发模型

使用fork完成并发

1.创建套接字  绑定  监听
2.等待接收客户端请求 accept
3.创建子进程处理客户端请求，
  父进程继续准备接收其他客户端连接
4.客户端退出则子进程结束

tftp文件服务器

项目功能: 
* 客户端有简单的页面命令提示
* 功能包含 
        1. 查看服务端文件库文件列表
        2. 下载其中的某个文件到本地
        3. 将本地文件上传到服务器文件库中
        4. 退出
* 服务端需要：
        1.处理客户端的各种请求
        2.允许多个客户端同时进行操作

技术分析:tcp套接字
 并发 --->   
          多进程
          对文件的读写发送操作
          查看文件列表时需要考虑到粘包问题

整体结构:功能封装在类中(上传，下载，查看列表)
os.listdir(path) 获取目录中文件列表
os.path.isfile() 判断是否为普通文件
os.path.isdir()  判断是否为目录

流程控制使用main()
创建套接字，创建连接创建进程，接收请求+


作业:完成get和put功能


